#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';
import crypto from 'node:crypto';
import { spawnSync } from 'node:child_process';
import Ajv2020 from 'ajv/dist/2020.js';

const REQUIRED_STANDARD = [
  'PREFLIGHT.log',
  'COMMANDS.log',
  'SNAPSHOT.md',
  'SUMMARY.md',
  'VERDICT.md',
  'SHA256SUMS.EVIDENCE',
  'pack_index.json'
];

const sha256File = (filePath) => crypto.createHash('sha256').update(fs.readFileSync(filePath)).digest('hex');
const nowIso = () => new Date().toISOString();

function parseArgs(argv) {
  const [command, ...rest] = argv;
  const args = { command, id: null };
  for (let i = 0; i < rest.length; i += 1) {
    if (rest[i] === '--id') args.id = rest[i + 1] ?? null;
  }
  return args;
}

function toEpochId(idArg) {
  const raw = idArg ?? process.env.EPOCH_ID;
  if (!raw) throw new Error('missing --id (e.g. --id 48)');
  const n = Number(raw);
  if (!Number.isInteger(n) || n <= 0) throw new Error(`invalid epoch id: ${raw}`);
  return `EPOCH-${String(n).padStart(2, '0')}`;
}

function gateStatusFromText(text) {
  if (/FAILED:\s*0\b/.test(text)) return 'PASS';
  if (/verify:[^\n]* FAILED/.test(text)) return 'FAIL';
  if (/\bFAILED:\s*[1-9]\d*\b/.test(text)) return 'FAIL';
  if (/\bPASSED\b|\bPASS\b/.test(text)) return 'PASS';
  return 'UNKNOWN';
}

function collectGateRuns(epochDir) {
  const gatesDir = path.join(epochDir, 'gates');
  if (!fs.existsSync(gatesDir)) return [];
  const files = fs.readdirSync(gatesDir).filter((f) => f.endsWith('.log')).filter((f) => !f.startsWith('pack_')).sort();
  return files.map((name) => {
    const fullPath = path.join(gatesDir, name);
    const text = fs.readFileSync(fullPath, 'utf8');
    return {
      path: `gates/${name}`,
      sha256: sha256File(fullPath),
      status: gateStatusFromText(text)
    };
  });
}

function buildPackIndex(epochId, epochDir, gateRuns) {
  const sha = spawnSync('git', ['rev-parse', 'HEAD'], { encoding: 'utf8' }).stdout.trim();
  const node = spawnSync('node', ['-v'], { encoding: 'utf8' }).stdout.trim();
  const npm = spawnSync('npm', ['-v'], { encoding: 'utf8' }).stdout.trim();

  const artifactFiles = fs.readdirSync(epochDir)
    .filter((f) => fs.statSync(path.join(epochDir, f)).isFile())
    .filter((f) => !REQUIRED_STANDARD.includes(f))
    .sort();

  const artifacts = artifactFiles.map((f) => ({
    path: f,
    sha256: sha256File(path.join(epochDir, f))
  }));

  const hashes = {};
  for (const f of ['PREFLIGHT.log', 'COMMANDS.log', 'SNAPSHOT.md', 'SUMMARY.md', 'VERDICT.md']) {
    const full = path.join(epochDir, f);
    if (fs.existsSync(full)) hashes[f] = sha256File(full);
  }

  return {
    epoch_id: epochId,
    sha,
    node,
    npm,
    date: nowIso(),
    gate_runs: gateRuns,
    artifacts,
    hashes
  };
}

function writeShaSums(epochDir) {
  const files = [];
  function walk(current) {
    const entries = fs.readdirSync(current).sort();
    for (const e of entries) {
      const full = path.join(current, e);
      const stat = fs.statSync(full);
      if (stat.isDirectory()) walk(full);
      else if (path.basename(full) !== 'SHA256SUMS.EVIDENCE') files.push(full);
    }
  }
  walk(epochDir);
  files.sort((a, b) => a.localeCompare(b));
  const lines = files.map((f) => `${sha256File(f)}  ./${path.relative(epochDir, f).replaceAll('\\', '/')}`);
  fs.writeFileSync(path.join(epochDir, 'SHA256SUMS.EVIDENCE'), `${lines.join('\n')}\n`);
}

function packEpoch(epochId) {
  const epochDir = path.resolve('reports/evidence', epochId);
  fs.mkdirSync(path.join(epochDir, 'gates'), { recursive: true });

  const preflight = path.join(epochDir, 'PREFLIGHT.log');
  if (!fs.existsSync(preflight)) {
    fs.writeFileSync(preflight, `generated_by=packager\nepoch=${epochId}\ndate=${nowIso()}\n`);
  }

  const commands = path.join(epochDir, 'COMMANDS.log');
  if (!fs.existsSync(commands)) {
    fs.writeFileSync(commands, '# commands unavailable: generated by packager without captured execution stream\n');
  }

  const gateRuns = collectGateRuns(epochDir);
  const failing = gateRuns.filter((g) => g.status === 'FAIL').length;
  const unknown = gateRuns.filter((g) => g.status === 'UNKNOWN').length;
  const hasLogs = gateRuns.length > 0;
  const passCount = gateRuns.filter((g) => g.status === 'PASS').length;
  const verdict = hasLogs && failing === 0 && passCount > 0 ? 'PASS' : 'BLOCKED';

  const snapshotLines = [
    `# ${epochId} SNAPSHOT`,
    `- evidence_root: \`reports/evidence/${epochId}/\``,
    `- gate_logs: ${gateRuns.length}`,
    `- failing_gate_logs: ${failing}`,
    `- unknown_gate_logs: ${unknown}`,
    '- gate_runs:'
  ];
  for (const g of gateRuns) snapshotLines.push(`  - \`${g.path}\` [${g.status}] \`${g.sha256}\``);
  fs.writeFileSync(path.join(epochDir, 'SNAPSHOT.md'), `${snapshotLines.join('\n')}\n`);

  const summary = [
    `# ${epochId} SUMMARY`,
    '- Generated by `scripts/evidence/packager.mjs pack:epoch` from real gate logs.',
    `- Gate runs discovered: ${gateRuns.length}`,
    `- PASS logs: ${gateRuns.filter((g) => g.status === 'PASS').length}`,
    `- FAIL logs: ${failing}`,
    `- UNKNOWN logs: ${unknown}`
  ].join('\n');
  fs.writeFileSync(path.join(epochDir, 'SUMMARY.md'), `${summary}\n`);

  const verdictText = [
    `# ${epochId} VERDICT`,
    `- Verdict: ${verdict}`,
    '- Derived from gate log statuses in `gates/*.log`.',
    verdict === 'PASS' ? '- Criteria met: all discovered logs indicate PASS.' : '- Criteria not met: at least one missing/failing/unknown gate result.'
  ].join('\n');
  fs.writeFileSync(path.join(epochDir, 'VERDICT.md'), `${verdictText}\n`);

  const packIndex = buildPackIndex(epochId, epochDir, gateRuns);
  fs.writeFileSync(path.join(epochDir, 'pack_index.json'), `${JSON.stringify(packIndex, null, 2)}\n`);

  writeShaSums(epochDir);
  console.log(`pack:epoch complete for ${epochId} (${verdict})`);
}

function parseShaFile(shaPath) {
  const lines = fs.readFileSync(shaPath, 'utf8').split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
  const map = new Map();
  for (const line of lines) {
    const m = line.match(/^([a-f0-9]{64})\s+\*?\.?\/?(.+)$/);
    if (!m) continue;
    map.set(m[2], m[1]);
  }
  return map;
}


function validatePackIndexSchema(index) {
  const schemaPath = path.resolve('schemas/evidence/pack_index.schema.json');
  const schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));
  const ajv = new Ajv2020({ allErrors: true, strict: false });
  const validate = ajv.compile(schema);
  const ok = validate(index);
  if (ok) return [];
  return (validate.errors ?? []).map((e) => `${e.instancePath || '/'} ${e.message}`);
}

function verifyPack(epochId) {
  const epochDir = path.resolve('reports/evidence', epochId);
  const errors = [];

  for (const f of REQUIRED_STANDARD) {
    if (!fs.existsSync(path.join(epochDir, f))) errors.push(`missing required file: ${f}`);
  }

  if (errors.length) {
    console.error('pack:verify FAILED');
    for (const e of errors) console.error(`- ${e}`);
    process.exit(1);
  }

  const index = JSON.parse(fs.readFileSync(path.join(epochDir, 'pack_index.json'), 'utf8'));
  const schemaErrors = validatePackIndexSchema(index);
  for (const e of schemaErrors) errors.push(`pack_index schema: ${e}`);
  if (index.epoch_id !== epochId) errors.push(`pack_index epoch_id mismatch: ${index.epoch_id} != ${epochId}`);

  const shaMap = parseShaFile(path.join(epochDir, 'SHA256SUMS.EVIDENCE'));
  if (!shaMap.has('pack_index.json')) errors.push('SHA256SUMS.EVIDENCE must include pack_index.json');

  for (const run of index.gate_runs ?? []) {
    const rel = run.path;
    const full = path.join(epochDir, rel);
    if (!fs.existsSync(full)) {
      errors.push(`gate run missing: ${rel}`);
      continue;
    }
    const actual = sha256File(full);
    if (actual !== run.sha256) errors.push(`gate run hash mismatch: ${rel}`);
    if (shaMap.get(rel) !== actual) errors.push(`SHA256SUMS mismatch for ${rel}`);
  }

  for (const item of index.artifacts ?? []) {
    const full = path.join(epochDir, item.path);
    if (!fs.existsSync(full)) {
      errors.push(`artifact missing: ${item.path}`);
      continue;
    }
    const actual = sha256File(full);
    if (actual !== item.sha256) errors.push(`artifact hash mismatch: ${item.path}`);
  }

  if (errors.length) {
    console.error('pack:verify FAILED');
    for (const e of errors) console.error(`- ${e}`);
    process.exit(1);
  }

  console.log(`pack:verify PASSED for ${epochId}`);
}

const args = parseArgs(process.argv.slice(2));
if (!args.command || !['pack:epoch', 'pack:verify'].includes(args.command)) {
  console.error('usage: node scripts/evidence/packager.mjs <pack:epoch|pack:verify> --id <NN>');
  process.exit(1);
}

const epochId = toEpochId(args.id);
if (args.command === 'pack:epoch') packEpoch(epochId);
if (args.command === 'pack:verify') verifyPack(epochId);
